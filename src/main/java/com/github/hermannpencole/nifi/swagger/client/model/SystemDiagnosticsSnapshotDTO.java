/*
 * NiFi Rest Api
 * The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * OpenAPI spec version: 1.5.0
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.github.hermannpencole.nifi.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.github.hermannpencole.nifi.swagger.client.model.GarbageCollectionDTO;
import com.github.hermannpencole.nifi.swagger.client.model.StorageUsageDTO;
import com.github.hermannpencole.nifi.swagger.client.model.VersionInfoDTO;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * SystemDiagnosticsSnapshotDTO
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-03-03T16:29:45.931+01:00")
public class SystemDiagnosticsSnapshotDTO {
  @SerializedName("totalNonHeap")
  private String totalNonHeap = null;

  @SerializedName("totalNonHeapBytes")
  private Long totalNonHeapBytes = null;

  @SerializedName("usedNonHeap")
  private String usedNonHeap = null;

  @SerializedName("usedNonHeapBytes")
  private Long usedNonHeapBytes = null;

  @SerializedName("freeNonHeap")
  private String freeNonHeap = null;

  @SerializedName("freeNonHeapBytes")
  private Long freeNonHeapBytes = null;

  @SerializedName("maxNonHeap")
  private String maxNonHeap = null;

  @SerializedName("maxNonHeapBytes")
  private Long maxNonHeapBytes = null;

  @SerializedName("nonHeapUtilization")
  private String nonHeapUtilization = null;

  @SerializedName("totalHeap")
  private String totalHeap = null;

  @SerializedName("totalHeapBytes")
  private Long totalHeapBytes = null;

  @SerializedName("usedHeap")
  private String usedHeap = null;

  @SerializedName("usedHeapBytes")
  private Long usedHeapBytes = null;

  @SerializedName("freeHeap")
  private String freeHeap = null;

  @SerializedName("freeHeapBytes")
  private Long freeHeapBytes = null;

  @SerializedName("maxHeap")
  private String maxHeap = null;

  @SerializedName("maxHeapBytes")
  private Long maxHeapBytes = null;

  @SerializedName("heapUtilization")
  private String heapUtilization = null;

  @SerializedName("availableProcessors")
  private Integer availableProcessors = null;

  @SerializedName("processorLoadAverage")
  private Double processorLoadAverage = null;

  @SerializedName("totalThreads")
  private Integer totalThreads = null;

  @SerializedName("daemonThreads")
  private Integer daemonThreads = null;

  @SerializedName("uptime")
  private String uptime = null;

  @SerializedName("flowFileRepositoryStorageUsage")
  private StorageUsageDTO flowFileRepositoryStorageUsage = null;

  @SerializedName("contentRepositoryStorageUsage")
  private List<StorageUsageDTO> contentRepositoryStorageUsage = null;

  @SerializedName("provenanceRepositoryStorageUsage")
  private List<StorageUsageDTO> provenanceRepositoryStorageUsage = null;

  @SerializedName("garbageCollection")
  private List<GarbageCollectionDTO> garbageCollection = null;

  @SerializedName("statsLastRefreshed")
  private String statsLastRefreshed = null;

  @SerializedName("versionInfo")
  private VersionInfoDTO versionInfo = null;

  public SystemDiagnosticsSnapshotDTO totalNonHeap(String totalNonHeap) {
    this.totalNonHeap = totalNonHeap;
    return this;
  }

   /**
   * Total size of non heap.
   * @return totalNonHeap
  **/
  @ApiModelProperty(value = "Total size of non heap.")
  public String getTotalNonHeap() {
    return totalNonHeap;
  }

  public void setTotalNonHeap(String totalNonHeap) {
    this.totalNonHeap = totalNonHeap;
  }

  public SystemDiagnosticsSnapshotDTO totalNonHeapBytes(Long totalNonHeapBytes) {
    this.totalNonHeapBytes = totalNonHeapBytes;
    return this;
  }

   /**
   * Total number of bytes allocated to the JVM not used for heap
   * @return totalNonHeapBytes
  **/
  @ApiModelProperty(value = "Total number of bytes allocated to the JVM not used for heap")
  public Long getTotalNonHeapBytes() {
    return totalNonHeapBytes;
  }

  public void setTotalNonHeapBytes(Long totalNonHeapBytes) {
    this.totalNonHeapBytes = totalNonHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO usedNonHeap(String usedNonHeap) {
    this.usedNonHeap = usedNonHeap;
    return this;
  }

   /**
   * Amount of use non heap.
   * @return usedNonHeap
  **/
  @ApiModelProperty(value = "Amount of use non heap.")
  public String getUsedNonHeap() {
    return usedNonHeap;
  }

  public void setUsedNonHeap(String usedNonHeap) {
    this.usedNonHeap = usedNonHeap;
  }

  public SystemDiagnosticsSnapshotDTO usedNonHeapBytes(Long usedNonHeapBytes) {
    this.usedNonHeapBytes = usedNonHeapBytes;
    return this;
  }

   /**
   * Total number of bytes used by the JVM not in the heap space
   * @return usedNonHeapBytes
  **/
  @ApiModelProperty(value = "Total number of bytes used by the JVM not in the heap space")
  public Long getUsedNonHeapBytes() {
    return usedNonHeapBytes;
  }

  public void setUsedNonHeapBytes(Long usedNonHeapBytes) {
    this.usedNonHeapBytes = usedNonHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO freeNonHeap(String freeNonHeap) {
    this.freeNonHeap = freeNonHeap;
    return this;
  }

   /**
   * Amount of free non heap.
   * @return freeNonHeap
  **/
  @ApiModelProperty(value = "Amount of free non heap.")
  public String getFreeNonHeap() {
    return freeNonHeap;
  }

  public void setFreeNonHeap(String freeNonHeap) {
    this.freeNonHeap = freeNonHeap;
  }

  public SystemDiagnosticsSnapshotDTO freeNonHeapBytes(Long freeNonHeapBytes) {
    this.freeNonHeapBytes = freeNonHeapBytes;
    return this;
  }

   /**
   * Total number of free non-heap bytes available to the JVM
   * @return freeNonHeapBytes
  **/
  @ApiModelProperty(value = "Total number of free non-heap bytes available to the JVM")
  public Long getFreeNonHeapBytes() {
    return freeNonHeapBytes;
  }

  public void setFreeNonHeapBytes(Long freeNonHeapBytes) {
    this.freeNonHeapBytes = freeNonHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO maxNonHeap(String maxNonHeap) {
    this.maxNonHeap = maxNonHeap;
    return this;
  }

   /**
   * Maximum size of non heap.
   * @return maxNonHeap
  **/
  @ApiModelProperty(value = "Maximum size of non heap.")
  public String getMaxNonHeap() {
    return maxNonHeap;
  }

  public void setMaxNonHeap(String maxNonHeap) {
    this.maxNonHeap = maxNonHeap;
  }

  public SystemDiagnosticsSnapshotDTO maxNonHeapBytes(Long maxNonHeapBytes) {
    this.maxNonHeapBytes = maxNonHeapBytes;
    return this;
  }

   /**
   * The maximum number of bytes that the JVM can use for non-heap purposes
   * @return maxNonHeapBytes
  **/
  @ApiModelProperty(value = "The maximum number of bytes that the JVM can use for non-heap purposes")
  public Long getMaxNonHeapBytes() {
    return maxNonHeapBytes;
  }

  public void setMaxNonHeapBytes(Long maxNonHeapBytes) {
    this.maxNonHeapBytes = maxNonHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO nonHeapUtilization(String nonHeapUtilization) {
    this.nonHeapUtilization = nonHeapUtilization;
    return this;
  }

   /**
   * Utilization of non heap.
   * @return nonHeapUtilization
  **/
  @ApiModelProperty(value = "Utilization of non heap.")
  public String getNonHeapUtilization() {
    return nonHeapUtilization;
  }

  public void setNonHeapUtilization(String nonHeapUtilization) {
    this.nonHeapUtilization = nonHeapUtilization;
  }

  public SystemDiagnosticsSnapshotDTO totalHeap(String totalHeap) {
    this.totalHeap = totalHeap;
    return this;
  }

   /**
   * Total size of heap.
   * @return totalHeap
  **/
  @ApiModelProperty(value = "Total size of heap.")
  public String getTotalHeap() {
    return totalHeap;
  }

  public void setTotalHeap(String totalHeap) {
    this.totalHeap = totalHeap;
  }

  public SystemDiagnosticsSnapshotDTO totalHeapBytes(Long totalHeapBytes) {
    this.totalHeapBytes = totalHeapBytes;
    return this;
  }

   /**
   * The total number of bytes that are available for the JVM heap to use
   * @return totalHeapBytes
  **/
  @ApiModelProperty(value = "The total number of bytes that are available for the JVM heap to use")
  public Long getTotalHeapBytes() {
    return totalHeapBytes;
  }

  public void setTotalHeapBytes(Long totalHeapBytes) {
    this.totalHeapBytes = totalHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO usedHeap(String usedHeap) {
    this.usedHeap = usedHeap;
    return this;
  }

   /**
   * Amount of used heap.
   * @return usedHeap
  **/
  @ApiModelProperty(value = "Amount of used heap.")
  public String getUsedHeap() {
    return usedHeap;
  }

  public void setUsedHeap(String usedHeap) {
    this.usedHeap = usedHeap;
  }

  public SystemDiagnosticsSnapshotDTO usedHeapBytes(Long usedHeapBytes) {
    this.usedHeapBytes = usedHeapBytes;
    return this;
  }

   /**
   * The number of bytes of JVM heap that are currently being used
   * @return usedHeapBytes
  **/
  @ApiModelProperty(value = "The number of bytes of JVM heap that are currently being used")
  public Long getUsedHeapBytes() {
    return usedHeapBytes;
  }

  public void setUsedHeapBytes(Long usedHeapBytes) {
    this.usedHeapBytes = usedHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO freeHeap(String freeHeap) {
    this.freeHeap = freeHeap;
    return this;
  }

   /**
   * Amount of free heap.
   * @return freeHeap
  **/
  @ApiModelProperty(value = "Amount of free heap.")
  public String getFreeHeap() {
    return freeHeap;
  }

  public void setFreeHeap(String freeHeap) {
    this.freeHeap = freeHeap;
  }

  public SystemDiagnosticsSnapshotDTO freeHeapBytes(Long freeHeapBytes) {
    this.freeHeapBytes = freeHeapBytes;
    return this;
  }

   /**
   * The number of bytes that are allocated to the JVM heap but not currently being used
   * @return freeHeapBytes
  **/
  @ApiModelProperty(value = "The number of bytes that are allocated to the JVM heap but not currently being used")
  public Long getFreeHeapBytes() {
    return freeHeapBytes;
  }

  public void setFreeHeapBytes(Long freeHeapBytes) {
    this.freeHeapBytes = freeHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO maxHeap(String maxHeap) {
    this.maxHeap = maxHeap;
    return this;
  }

   /**
   * Maximum size of heap.
   * @return maxHeap
  **/
  @ApiModelProperty(value = "Maximum size of heap.")
  public String getMaxHeap() {
    return maxHeap;
  }

  public void setMaxHeap(String maxHeap) {
    this.maxHeap = maxHeap;
  }

  public SystemDiagnosticsSnapshotDTO maxHeapBytes(Long maxHeapBytes) {
    this.maxHeapBytes = maxHeapBytes;
    return this;
  }

   /**
   * The maximum number of bytes that can be used by the JVM
   * @return maxHeapBytes
  **/
  @ApiModelProperty(value = "The maximum number of bytes that can be used by the JVM")
  public Long getMaxHeapBytes() {
    return maxHeapBytes;
  }

  public void setMaxHeapBytes(Long maxHeapBytes) {
    this.maxHeapBytes = maxHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO heapUtilization(String heapUtilization) {
    this.heapUtilization = heapUtilization;
    return this;
  }

   /**
   * Utilization of heap.
   * @return heapUtilization
  **/
  @ApiModelProperty(value = "Utilization of heap.")
  public String getHeapUtilization() {
    return heapUtilization;
  }

  public void setHeapUtilization(String heapUtilization) {
    this.heapUtilization = heapUtilization;
  }

  public SystemDiagnosticsSnapshotDTO availableProcessors(Integer availableProcessors) {
    this.availableProcessors = availableProcessors;
    return this;
  }

   /**
   * Number of available processors if supported by the underlying system.
   * @return availableProcessors
  **/
  @ApiModelProperty(value = "Number of available processors if supported by the underlying system.")
  public Integer getAvailableProcessors() {
    return availableProcessors;
  }

  public void setAvailableProcessors(Integer availableProcessors) {
    this.availableProcessors = availableProcessors;
  }

  public SystemDiagnosticsSnapshotDTO processorLoadAverage(Double processorLoadAverage) {
    this.processorLoadAverage = processorLoadAverage;
    return this;
  }

   /**
   * The processor load average if supported by the underlying system.
   * @return processorLoadAverage
  **/
  @ApiModelProperty(value = "The processor load average if supported by the underlying system.")
  public Double getProcessorLoadAverage() {
    return processorLoadAverage;
  }

  public void setProcessorLoadAverage(Double processorLoadAverage) {
    this.processorLoadAverage = processorLoadAverage;
  }

  public SystemDiagnosticsSnapshotDTO totalThreads(Integer totalThreads) {
    this.totalThreads = totalThreads;
    return this;
  }

   /**
   * Total number of threads.
   * @return totalThreads
  **/
  @ApiModelProperty(value = "Total number of threads.")
  public Integer getTotalThreads() {
    return totalThreads;
  }

  public void setTotalThreads(Integer totalThreads) {
    this.totalThreads = totalThreads;
  }

  public SystemDiagnosticsSnapshotDTO daemonThreads(Integer daemonThreads) {
    this.daemonThreads = daemonThreads;
    return this;
  }

   /**
   * Number of daemon threads.
   * @return daemonThreads
  **/
  @ApiModelProperty(value = "Number of daemon threads.")
  public Integer getDaemonThreads() {
    return daemonThreads;
  }

  public void setDaemonThreads(Integer daemonThreads) {
    this.daemonThreads = daemonThreads;
  }

  public SystemDiagnosticsSnapshotDTO uptime(String uptime) {
    this.uptime = uptime;
    return this;
  }

   /**
   * The uptime of the Java virtual machine
   * @return uptime
  **/
  @ApiModelProperty(value = "The uptime of the Java virtual machine")
  public String getUptime() {
    return uptime;
  }

  public void setUptime(String uptime) {
    this.uptime = uptime;
  }

  public SystemDiagnosticsSnapshotDTO flowFileRepositoryStorageUsage(StorageUsageDTO flowFileRepositoryStorageUsage) {
    this.flowFileRepositoryStorageUsage = flowFileRepositoryStorageUsage;
    return this;
  }

   /**
   * The flowfile repository storage usage.
   * @return flowFileRepositoryStorageUsage
  **/
  @ApiModelProperty(value = "The flowfile repository storage usage.")
  public StorageUsageDTO getFlowFileRepositoryStorageUsage() {
    return flowFileRepositoryStorageUsage;
  }

  public void setFlowFileRepositoryStorageUsage(StorageUsageDTO flowFileRepositoryStorageUsage) {
    this.flowFileRepositoryStorageUsage = flowFileRepositoryStorageUsage;
  }

  public SystemDiagnosticsSnapshotDTO contentRepositoryStorageUsage(List<StorageUsageDTO> contentRepositoryStorageUsage) {
    this.contentRepositoryStorageUsage = contentRepositoryStorageUsage;
    return this;
  }

  public SystemDiagnosticsSnapshotDTO addContentRepositoryStorageUsageItem(StorageUsageDTO contentRepositoryStorageUsageItem) {
    if (this.contentRepositoryStorageUsage == null) {
      this.contentRepositoryStorageUsage = new ArrayList<StorageUsageDTO>();
    }
    this.contentRepositoryStorageUsage.add(contentRepositoryStorageUsageItem);
    return this;
  }

   /**
   * The content repository storage usage.
   * @return contentRepositoryStorageUsage
  **/
  @ApiModelProperty(value = "The content repository storage usage.")
  public List<StorageUsageDTO> getContentRepositoryStorageUsage() {
    return contentRepositoryStorageUsage;
  }

  public void setContentRepositoryStorageUsage(List<StorageUsageDTO> contentRepositoryStorageUsage) {
    this.contentRepositoryStorageUsage = contentRepositoryStorageUsage;
  }

  public SystemDiagnosticsSnapshotDTO provenanceRepositoryStorageUsage(List<StorageUsageDTO> provenanceRepositoryStorageUsage) {
    this.provenanceRepositoryStorageUsage = provenanceRepositoryStorageUsage;
    return this;
  }

  public SystemDiagnosticsSnapshotDTO addProvenanceRepositoryStorageUsageItem(StorageUsageDTO provenanceRepositoryStorageUsageItem) {
    if (this.provenanceRepositoryStorageUsage == null) {
      this.provenanceRepositoryStorageUsage = new ArrayList<StorageUsageDTO>();
    }
    this.provenanceRepositoryStorageUsage.add(provenanceRepositoryStorageUsageItem);
    return this;
  }

   /**
   * The provenance repository storage usage.
   * @return provenanceRepositoryStorageUsage
  **/
  @ApiModelProperty(value = "The provenance repository storage usage.")
  public List<StorageUsageDTO> getProvenanceRepositoryStorageUsage() {
    return provenanceRepositoryStorageUsage;
  }

  public void setProvenanceRepositoryStorageUsage(List<StorageUsageDTO> provenanceRepositoryStorageUsage) {
    this.provenanceRepositoryStorageUsage = provenanceRepositoryStorageUsage;
  }

  public SystemDiagnosticsSnapshotDTO garbageCollection(List<GarbageCollectionDTO> garbageCollection) {
    this.garbageCollection = garbageCollection;
    return this;
  }

  public SystemDiagnosticsSnapshotDTO addGarbageCollectionItem(GarbageCollectionDTO garbageCollectionItem) {
    if (this.garbageCollection == null) {
      this.garbageCollection = new ArrayList<GarbageCollectionDTO>();
    }
    this.garbageCollection.add(garbageCollectionItem);
    return this;
  }

   /**
   * The garbage collection details.
   * @return garbageCollection
  **/
  @ApiModelProperty(value = "The garbage collection details.")
  public List<GarbageCollectionDTO> getGarbageCollection() {
    return garbageCollection;
  }

  public void setGarbageCollection(List<GarbageCollectionDTO> garbageCollection) {
    this.garbageCollection = garbageCollection;
  }

  public SystemDiagnosticsSnapshotDTO statsLastRefreshed(String statsLastRefreshed) {
    this.statsLastRefreshed = statsLastRefreshed;
    return this;
  }

   /**
   * When the diagnostics were generated.
   * @return statsLastRefreshed
  **/
  @ApiModelProperty(value = "When the diagnostics were generated.")
  public String getStatsLastRefreshed() {
    return statsLastRefreshed;
  }

  public void setStatsLastRefreshed(String statsLastRefreshed) {
    this.statsLastRefreshed = statsLastRefreshed;
  }

  public SystemDiagnosticsSnapshotDTO versionInfo(VersionInfoDTO versionInfo) {
    this.versionInfo = versionInfo;
    return this;
  }

   /**
   * The nifi, os, java, and build version information
   * @return versionInfo
  **/
  @ApiModelProperty(value = "The nifi, os, java, and build version information")
  public VersionInfoDTO getVersionInfo() {
    return versionInfo;
  }

  public void setVersionInfo(VersionInfoDTO versionInfo) {
    this.versionInfo = versionInfo;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SystemDiagnosticsSnapshotDTO systemDiagnosticsSnapshotDTO = (SystemDiagnosticsSnapshotDTO) o;
    return Objects.equals(this.totalNonHeap, systemDiagnosticsSnapshotDTO.totalNonHeap) &&
        Objects.equals(this.totalNonHeapBytes, systemDiagnosticsSnapshotDTO.totalNonHeapBytes) &&
        Objects.equals(this.usedNonHeap, systemDiagnosticsSnapshotDTO.usedNonHeap) &&
        Objects.equals(this.usedNonHeapBytes, systemDiagnosticsSnapshotDTO.usedNonHeapBytes) &&
        Objects.equals(this.freeNonHeap, systemDiagnosticsSnapshotDTO.freeNonHeap) &&
        Objects.equals(this.freeNonHeapBytes, systemDiagnosticsSnapshotDTO.freeNonHeapBytes) &&
        Objects.equals(this.maxNonHeap, systemDiagnosticsSnapshotDTO.maxNonHeap) &&
        Objects.equals(this.maxNonHeapBytes, systemDiagnosticsSnapshotDTO.maxNonHeapBytes) &&
        Objects.equals(this.nonHeapUtilization, systemDiagnosticsSnapshotDTO.nonHeapUtilization) &&
        Objects.equals(this.totalHeap, systemDiagnosticsSnapshotDTO.totalHeap) &&
        Objects.equals(this.totalHeapBytes, systemDiagnosticsSnapshotDTO.totalHeapBytes) &&
        Objects.equals(this.usedHeap, systemDiagnosticsSnapshotDTO.usedHeap) &&
        Objects.equals(this.usedHeapBytes, systemDiagnosticsSnapshotDTO.usedHeapBytes) &&
        Objects.equals(this.freeHeap, systemDiagnosticsSnapshotDTO.freeHeap) &&
        Objects.equals(this.freeHeapBytes, systemDiagnosticsSnapshotDTO.freeHeapBytes) &&
        Objects.equals(this.maxHeap, systemDiagnosticsSnapshotDTO.maxHeap) &&
        Objects.equals(this.maxHeapBytes, systemDiagnosticsSnapshotDTO.maxHeapBytes) &&
        Objects.equals(this.heapUtilization, systemDiagnosticsSnapshotDTO.heapUtilization) &&
        Objects.equals(this.availableProcessors, systemDiagnosticsSnapshotDTO.availableProcessors) &&
        Objects.equals(this.processorLoadAverage, systemDiagnosticsSnapshotDTO.processorLoadAverage) &&
        Objects.equals(this.totalThreads, systemDiagnosticsSnapshotDTO.totalThreads) &&
        Objects.equals(this.daemonThreads, systemDiagnosticsSnapshotDTO.daemonThreads) &&
        Objects.equals(this.uptime, systemDiagnosticsSnapshotDTO.uptime) &&
        Objects.equals(this.flowFileRepositoryStorageUsage, systemDiagnosticsSnapshotDTO.flowFileRepositoryStorageUsage) &&
        Objects.equals(this.contentRepositoryStorageUsage, systemDiagnosticsSnapshotDTO.contentRepositoryStorageUsage) &&
        Objects.equals(this.provenanceRepositoryStorageUsage, systemDiagnosticsSnapshotDTO.provenanceRepositoryStorageUsage) &&
        Objects.equals(this.garbageCollection, systemDiagnosticsSnapshotDTO.garbageCollection) &&
        Objects.equals(this.statsLastRefreshed, systemDiagnosticsSnapshotDTO.statsLastRefreshed) &&
        Objects.equals(this.versionInfo, systemDiagnosticsSnapshotDTO.versionInfo);
  }

  @Override
  public int hashCode() {
    return Objects.hash(totalNonHeap, totalNonHeapBytes, usedNonHeap, usedNonHeapBytes, freeNonHeap, freeNonHeapBytes, maxNonHeap, maxNonHeapBytes, nonHeapUtilization, totalHeap, totalHeapBytes, usedHeap, usedHeapBytes, freeHeap, freeHeapBytes, maxHeap, maxHeapBytes, heapUtilization, availableProcessors, processorLoadAverage, totalThreads, daemonThreads, uptime, flowFileRepositoryStorageUsage, contentRepositoryStorageUsage, provenanceRepositoryStorageUsage, garbageCollection, statsLastRefreshed, versionInfo);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SystemDiagnosticsSnapshotDTO {\n");
    
    sb.append("    totalNonHeap: ").append(toIndentedString(totalNonHeap)).append("\n");
    sb.append("    totalNonHeapBytes: ").append(toIndentedString(totalNonHeapBytes)).append("\n");
    sb.append("    usedNonHeap: ").append(toIndentedString(usedNonHeap)).append("\n");
    sb.append("    usedNonHeapBytes: ").append(toIndentedString(usedNonHeapBytes)).append("\n");
    sb.append("    freeNonHeap: ").append(toIndentedString(freeNonHeap)).append("\n");
    sb.append("    freeNonHeapBytes: ").append(toIndentedString(freeNonHeapBytes)).append("\n");
    sb.append("    maxNonHeap: ").append(toIndentedString(maxNonHeap)).append("\n");
    sb.append("    maxNonHeapBytes: ").append(toIndentedString(maxNonHeapBytes)).append("\n");
    sb.append("    nonHeapUtilization: ").append(toIndentedString(nonHeapUtilization)).append("\n");
    sb.append("    totalHeap: ").append(toIndentedString(totalHeap)).append("\n");
    sb.append("    totalHeapBytes: ").append(toIndentedString(totalHeapBytes)).append("\n");
    sb.append("    usedHeap: ").append(toIndentedString(usedHeap)).append("\n");
    sb.append("    usedHeapBytes: ").append(toIndentedString(usedHeapBytes)).append("\n");
    sb.append("    freeHeap: ").append(toIndentedString(freeHeap)).append("\n");
    sb.append("    freeHeapBytes: ").append(toIndentedString(freeHeapBytes)).append("\n");
    sb.append("    maxHeap: ").append(toIndentedString(maxHeap)).append("\n");
    sb.append("    maxHeapBytes: ").append(toIndentedString(maxHeapBytes)).append("\n");
    sb.append("    heapUtilization: ").append(toIndentedString(heapUtilization)).append("\n");
    sb.append("    availableProcessors: ").append(toIndentedString(availableProcessors)).append("\n");
    sb.append("    processorLoadAverage: ").append(toIndentedString(processorLoadAverage)).append("\n");
    sb.append("    totalThreads: ").append(toIndentedString(totalThreads)).append("\n");
    sb.append("    daemonThreads: ").append(toIndentedString(daemonThreads)).append("\n");
    sb.append("    uptime: ").append(toIndentedString(uptime)).append("\n");
    sb.append("    flowFileRepositoryStorageUsage: ").append(toIndentedString(flowFileRepositoryStorageUsage)).append("\n");
    sb.append("    contentRepositoryStorageUsage: ").append(toIndentedString(contentRepositoryStorageUsage)).append("\n");
    sb.append("    provenanceRepositoryStorageUsage: ").append(toIndentedString(provenanceRepositoryStorageUsage)).append("\n");
    sb.append("    garbageCollection: ").append(toIndentedString(garbageCollection)).append("\n");
    sb.append("    statsLastRefreshed: ").append(toIndentedString(statsLastRefreshed)).append("\n");
    sb.append("    versionInfo: ").append(toIndentedString(versionInfo)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

